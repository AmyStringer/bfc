\documentclass{bioinfo}
\copyrightyear{2015}
\pubyear{2015}

\usepackage{amsmath}
\usepackage[ruled,vlined]{algorithm2e}
\newcommand\mycommfont[1]{\footnotesize\rmfamily{\it #1}}
\SetCommentSty{mycommfont}
\SetKwComment{Comment}{$\triangleright$\ }{}
\usepackage{natbib}

\bibliographystyle{apalike}


\begin{document}
\firstpage{1}

\title[Error Correction for Illumina Data]{Correcting Illumina sequencing errors for human data}

\author[Li]{Heng Li}

\address{Broad Institute, 75 Ames Street, Cambridge, MA 02142, USA}

\history{Received on XXXXX; revised on XXXXX; accepted on XXXXX}
\editor{Associate Editor: XXXXXXX}
\maketitle

\begin{abstract}
\section{Summary:}

\section{Availability and implementation:} https://github.com/lh3/bfc

\section{Contact:} hengli@broadinstitute.org
\end{abstract}

\section{Introduction}

\begin{methods}
\section{Methods}
The BFC error correction algorithm is a $k$-mer spectrum
algorithm~\citep{Pevzner:2001vn}, which takes a list of trusted $k$-mers and
attempts to find a corrected sequence such that each $k$-mer on the corrected
sequence is trusted. There are multiple ways to implement this basic idea.
Algorithm~1 gives the BFC implementation. It defines a \emph{state} of
correction as a 4-tuple $(i,W,\mathcal{C},p)$, which consists of the position
$i$ of the last visited base, the preceding \mbox{($k$-1)--mer} $W$ ending at
$i$, the set $\mathcal{C}$ of previous corrected positions and bases (called a
\emph{solution}) up to $i$, and the penalty $p$ of solution $\mathcal{C}$.  BFC
keeps all possible states in a priority queue $\mathcal{Q}$. At each iteration,
it retrieves the state $(i,W,\mathcal{C},p)$ with the lowest penalty $p$ and
adds a new state $(i+1,W[1,k-2]\circ a,\mathcal{C}',p')$ if $a$ is the read
base or $W\circ a$ is a trusted $k$-mer. We find the optimal solution when we
come to the end of the read. This algorithm may change a base on a trusted
$k$-mer if doing this leads to more trusted $k$-mers later. Some algorithms
such as BLESS~\citep{Heo:2014aa} and Lighter~\citep{Song:2014aa} apparently do
not backtrack to change a wrong base assignment at an early iteration.

The worse-case time complexity of Algorithm~1 is exponential in the length of
the read. In implementation, we skip line~1 if the read base is Q20 and the
$k$-mer ending at it is trusted, or if five bases or two Q20 bases have been
corrected in the last 10bp window by default. The heuristics reduce the
search space. If BFC still takes too many iterations before finding an optimal
solution, we stop the search and mark the read not correctable.

\begin{algorithm}[ht]
\DontPrintSemicolon
\footnotesize
\KwIn{K-mer size $k$, set $\mathcal{H}$ of trusted k-mers, and one string $S$}
\KwOut{Set of corrected positions and bases changed to}
\BlankLine
\textbf{Function} {\sc CorrectErrors}$(k, \mathcal{H}, S)$
\Begin {
	$\mathcal{Q}\gets${\sc HeapInit}$()$\Comment*[r]{$\mathcal{Q}$ is a priority queue}
	{\sc HeapPush}$(\mathcal{Q}, (k-2, S[0,k-2], \emptyset, 0))$\Comment*[r]{0-based strings}
	\While{$\mathcal{Q}$ is not empty} {
		$(i, W, \mathcal{C}, p)\gets${\sc HeapPopBest}$(\mathcal{Q})$\Comment*[r]{current best state}
		$i\gets i+1$\;
		\lIf{$i=|S|$} { {\bf return} $\mathcal{C}$ \Comment*[f]{reaching the end of $S$}}
		\ForEach (\Comment*[f]{try all possible next base}) {$a\in\{{\rm A},{\rm C},{\rm G},{\rm T}\}$} {
			$W'\gets W\circ a$\Comment*[r]{``$\circ$'' concatenates strings}
			\uIf (\Comment*[f]{``$a$'' is the read base}) {$a=S[i]$} {
				\eIf (\Comment*[f]{then no penalty applied}) {$W'\in\mathcal{H}$} {
					{\sc HeapPush}$(\mathcal{Q}, (i,W'[1,k-1],\mathcal{C}, p))$\;
				} (\Comment*[f]{then apply penalty}) {
					{\sc HeapPush}$(\mathcal{Q}, (i,W'[1,k-1],\mathcal{C}, p+1))$\;
				}
			} \ElseIf (\Comment*[f]{correction made and $W'$ trusted}) {$W'\in \mathcal{H}$} {
				\nl{\sc HeapPush}$(\mathcal{Q}, (i,W'[1,k-1],\mathcal{C}\cup\{(i,a)\},p+1))$\;
			}
		}
	}
}
\caption{Error correction for one string in one direction}
\end{algorithm}

\end{methods}

\section{Results and Discussions}
\begin{table}[ht]
\processtable{Performance of error correction for 4 million human reads}
{\footnotesize
\begin{tabular}{lrrccrrc}
\toprule
Prog.     & Time & RAM   & Perfect & Chimeric & Better & Worse & Ambi. \\
\midrule
BFC       & 7.4h & 63.5G & {\bf 3.04M} & 12.5k&{\bf 820k}&{\bf 7.1k}&14.3k \\
BLESS     & 6.5h & 22.3G & 2.91M   & 13.1k    & 666k   & 15.2k & 14.8k \\
Bloocoo   &5.7h&{\bf 4.0G}& 2.88M  & 14.1k    & 751k   & 25.9k & 20.7k \\
Fermi2    &17.2h & 64.7G & 3.00M   & 17.7k    & 819k   & 29.1k & 47.6k \\
Lighter   &{\bf 3.2h}& 13.4G&2.98M & 13.0k    & 743k   & 22.4k & 21.8k \\
Musket    &21.6h & 77.5G & 2.94M   & 22.5k    & 760k   & 24.6k & 46.0k \\
SGA       &48.7h & 35.6G & 3.01M  &{\bf 12.1k}& 750k   & 10.0k & {\bf 10.1k} \\
\botrule
\end{tabular}}{Column meaning: the wall-clock \emph{time} when 16 threads
are specified if possible, the peak \emph{RAM} measured by GNU time, number of
reads mapped \emph{perfectly} to hs37d5 by BWA-MEM, number of \emph{chimeric}
reads, number of corrected reads \emph{better} than the original reads, number
of reads \emph{worse} than the original and number of corrected reads with some
aspects better but some worse than the original reads (column \emph{Ambi}).}
% Fiona, Trowel and AllPaths-LG used >11GB RAM and got manually killed
% RACER uses more RAM than input read bases (Molnar and Ilie, 2014). It is not tested.

\end{table}

\section*{Acknowledgement}
\paragraph{Funding\textcolon} NHGRI U54HG003037; NIH GM100233

\bibliography{bfc}
\end{document}
