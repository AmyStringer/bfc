\documentclass{bioinfo}
\copyrightyear{2015}
\pubyear{2015}

\usepackage{amsmath}
\usepackage[ruled,vlined]{algorithm2e}
\newcommand\mycommfont[1]{\footnotesize\rmfamily{\it #1}}
\SetCommentSty{mycommfont}
\SetKwComment{Comment}{$\triangleright$\ }{}
\usepackage{natbib}

\bibliographystyle{apalike}


\begin{document}
\firstpage{1}

\title[Error Correction for Illumina Data]{Correcting Illumina sequencing errors for human data}

\author[Li]{Heng Li}

\address{Broad Institute, 75 Ames Street, Cambridge, MA 02142, USA}

\history{Received on XXXXX; revised on XXXXX; accepted on XXXXX}
\editor{Associate Editor: XXXXXXX}
\maketitle

\begin{abstract}
\section{Summary:} We present a new tool to correct sequencing errors in
Illumina data produced from whole-genome shotgun resequencing. It uses a
non-greedy algorithm and shows comparable performance, better usability and
higher accuracy in an evaluation that has the most complete collection of
high-performance error correctors.

\section{Availability and implementation:} https://github.com/lh3/bfc

\section{Contact:} hengli@broadinstitute.org
\end{abstract}

\section{Introduction}

\emph{Error correction} is a process to fix sequencing errors on a sequence read
by using other overlapping reads that do not contain the errors. Many \emph{de
novo} assemblers, in particular short-read assemblers for large genomes, use
error correction to reduce the complexity of the assembly graph such that the
graph can be fitted to limited RAM. The most popular class of the error
correction algorithms is based on the $k$-mer spectrum~\citep{Pevzner:2001vn}.
It takes a list of trusted $k$-mers and attempts to find a sequence with
minimal corrections such that each $k$-mer on the corrected sequence is
trusted. Most fast implementations take a greedy approach. They make a
correction based on the local sequence context and do not revert the decision.
They may not find the sequence with the minimal corrections. We worried that
the greedy strategy might affect the accuracy given reads from a repeat-rich
diploid genome, so derived a new algorithm. It is optimal provided that we know
there is an error-free $k$-mer in the read.

\begin{methods}
\section{Methods}
Algorithm~1 is the key component of the BFC method. It defines a \emph{state}
of correction as a 4-tuple $(i,W,\mathcal{C},p)$, which consists of the
position $i$ of the preceding base, the last \mbox{($k$-1)--mer} $W$ ending at
$i$, the set $\mathcal{C}$ of previous corrected positions and bases (called a
\emph{solution}) up to $i$, and the penalty $p$ of solution $\mathcal{C}$. BFC
keeps all possible states in a priority queue $\mathcal{Q}$. At each iteration,
it retrieves the state $(i,W,\mathcal{C},p)$ with the lowest penalty $p$ and
adds a new state $(i+1,W[1,k-2]\circ a,\mathcal{C}',p')$ if $a$ is the read
base or $W\circ a$ is a trusted $k$-mer. If the first $k$-mer in $S$ is
error free and we remove line~1, this algorithm finds the optimal corrected
sequence.

The worse-case time complexity of Algorithm~1 is exponential in the length of
the read. In implementation, we skip line~1 if the read base is Q20 and the
$k$-mer ending at it is trusted, or if five bases or two Q20 bases have been
corrected in the last 10bp window by default. The heuristics reduce the
search space. If BFC still takes too many iterations before finding an optimal
solution, we stop the search and mark the read not correctable.

Given a read, BFC finds the longest substring on which each $k$-mer is trusted. It
then extends the substring to both ends of the read with Algorithm~1. If a read
does not contain any trusted $k$-mers, BFC exhaustively tests all $k$-mer
one hamming distance away from the first $k$-mer on the read to find a trusted
$k$-mer. It marks the read uncorrectable if this fails.

\begin{algorithm}[ht]
\DontPrintSemicolon
\footnotesize
\KwIn{K-mer size $k$, set $\mathcal{H}$ of trusted k-mers, and one string $S$}
\KwOut{Set of corrected positions and bases changed to}
\BlankLine
\textbf{Function} {\sc CorrectErrors}$(k, \mathcal{H}, S)$
\Begin {
	$\mathcal{Q}\gets${\sc HeapInit}$()$\Comment*[r]{$\mathcal{Q}$ is a priority queue}
	{\sc HeapPush}$(\mathcal{Q}, (k-2, S[0,k-2], \emptyset, 0))$\Comment*[r]{0-based strings}
	\While{$\mathcal{Q}$ is not empty} {
		$(i, W, \mathcal{C}, p)\gets${\sc HeapPopBest}$(\mathcal{Q})$\Comment*[r]{current best state}
		$i\gets i+1$\;
		\lIf{$i=|S|$} { {\bf return} $\mathcal{C}$ \Comment*[f]{reaching the end of $S$}}
		\ForEach (\Comment*[f]{try all possible next bases}) {$a\in\{{\rm A},{\rm C},{\rm G},{\rm T}\}$} {
			$W'\gets W\circ a$\Comment*[r]{``$\circ$'' concatenates strings}
			\uIf (\Comment*[f]{``$a$'' is the read base}) {$a=S[i]$} {
				\eIf (\Comment*[f]{good read base; no penalty}) {$W'\in\mathcal{H}$} {
					{\sc HeapPush}$(\mathcal{Q}, (i,W'[1,k-1],\mathcal{C}, p))$\;
				} (\Comment*[f]{bad read base; penalize}) {
					{\sc HeapPush}$(\mathcal{Q}, (i,W'[1,k-1],\mathcal{C}, p+1))$\;
				}
			} \ElseIf (\Comment*[f]{make a correction with penalty}) {$W'\in \mathcal{H}$} {
				\nl{\sc HeapPush}$(\mathcal{Q}, (i,W'[1,k-1],\mathcal{C}\cup\{(i,a)\},p+1))$\;
			}
		}
	}
}
\caption{Error correction for one string in one direction}
\end{algorithm}

\end{methods}

\section{Results and Discussions}

We evaluated BFC along with BLESS~\citep{Heo:2014aa},
Bloocoo~\citep{Drezen:2014aa}, fermi2~\citep{Li:2012fk},
Lighter~\citep{Song:2014aa}, Musket~\citep{Liu:2013ac} and
SGA~\citep{Simpson:2012aa} on real data (Table~1). We ran the tools on a Linux
server with 20 cores of Intel XXX CPUs with 128GB RAM. The command lines were
included in the BFC source code package (http://bit.ly/bfc-eval).  We have
considered AllPaths-LG~\citep{Gnerre:2011ys}, Coral~\citep{Salmela:2011aa},
Fiona~\citep{Schulz:2014aa}, HiTEC~\citep{Ilie:2011fk},
RACER~\citep{Ilie:2013aa}, SHREC~\citep{Schroder:2009uq} and
Trowel~\citep{Lim:2014aa}, but they require more RAM than our machine, so were
not tested.



\begin{table}[ht]
\processtable{Performance of error correction}
{\footnotesize
\begin{tabular}{lcrrcccr}
\toprule
Prog.     & $k$ & Time  & RAM   & Perfect&Chim.& Better & Worse \\
\midrule
BFC-ht    & 37  & 6h33m & 63.5G & 3.04M  & 12.5k  & 830k   & 9.7k \\
BFC-bf    & 31  & 7h32m & 23.3G & 3.01M  & 13.1k  & 783k   &{\bf 9.2k}\\
BFC-bf    & 55  & 4h41m & 23.3G&{\bf 3.05M}&11.8k & 819k   & 11.4k \\
BLESS     & 31  & 6h31m & 22.3G & 2.91M  & 13.1k  & 674k   & 20.8k \\
BLESS     & 55  & 5h09m & 22.3G & 3.01M  &{\bf 11.5k}& 775k& 10.3k \\
Bloocoo   & 31  & 5h52m &{\bf 4.0G}&2.88M& 14.1k  & 764k   & 31.5k  \\
Fermi2    & 29  &17h14m & 64.7G & 3.00M  & 17.7k  &{\bf 849k}&42.8k \\
Lighter   & 31  &{\bf 3h14m}& 13.4G&2.98M& 13.0k  & 756k   & 30.1k  \\
Musket    & 27  &21h33m & 77.5G & 2.94M  & 22.5k  & 790k   & 36.3k  \\
SGA       & 55  &48h40m & 35.6G & 3.01M  & 12.1k  & 755k   & 12.8k  \\
\botrule
\end{tabular}}{4.45 million pairs of $\sim$150bp reads were
downloaded from BaseSpace, under the sample ``NA12878-L7'' of project
``HiSeq X Ten: TruSeq Nano (4 replicates of NA12878)''. Reads were corrected
together. 55-mer for SGA was used according to its paper. The maximal k-mer
length was used for other tools except BLESS and BFC-bf. On a subset of two
million randomly sampled read pairs, the original and the corrected sequences
were mapped to hs37d5 (http://bit.ly/GRCh37d5) with BWA-MEM~\citep{Li:2013aa}.
A read is said to become \emph{better} (or \emph{worse}) if the best alignment
of the corrected sequence has more (or fewer) identical bases to the reference
genome than the best alignment of the original sequence. The table gives
$k$-mer size, the wall-clock \emph{time} when 16 threads are specified if
possible, the peak \emph{RAM} measured by GNU time, number of corrected reads
mapped \emph{perfectly}, number of \emph{chimeric} reads, number of corrected
reads becoming \emph{better} and the number of reads becoming \emph{worse} than
the original reads.}
% Fiona, Trowel and AllPaths-LG used >11GB RAM and got manually killed
% RACER uses more RAM than input read bases (Molnar and Ilie, 2014). It is not tested.

\end{table}

\section*{Acknowledgement}
\paragraph{Funding\textcolon} NHGRI U54HG003037; NIH GM100233

\bibliography{bfc}
\end{document}
